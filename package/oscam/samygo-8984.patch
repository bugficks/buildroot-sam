Index: config.h
===================================================================
--- a/config.h	(revision 8984)
+++ b/config.h	(working copy)
@@ -1,15 +1,16 @@
 #ifndef CONFIG_H_
 #define CONFIG_H_
 
+#define DVBAPI_SAMYGO 1
 #define WEBIF 1
 #define TOUCH 1
 //#define WITH_SSL 1
-#if defined(__linux__)
+#if defined(__linux__) || defined(DVBAPI_SAMYGO)
 #define HAVE_DVBAPI 1
 #endif
-#define IRDETO_GUESSING 1
+//#define IRDETO_GUESSING 1
 #define CS_ANTICASC 1
-#define WITH_DEBUG 1
+//#define WITH_DEBUG 1
 #define WITH_LB 1
 #define CS_CACHEEX 1
 #define CW_CYCLE_CHECK 1
@@ -25,36 +26,36 @@
 #define MODULE_CCCAM 1
 #define MODULE_CCCSHARE 1
 #define MODULE_GBOX 1
-#define MODULE_RADEGAST 1
-#define MODULE_SERIAL 1
+//#define MODULE_RADEGAST 1
+//#define MODULE_SERIAL 1
 #define MODULE_CONSTCW 1
-#define MODULE_PANDORA 1
-#define MODULE_GHTTP 1
+//#define MODULE_PANDORA 1
+//#define MODULE_GHTTP 1
 
-#define WITH_CARDREADER 1
+//#define WITH_CARDREADER 0
 
 #ifdef WITH_CARDREADER
 
-#define READER_NAGRA 1
-#define READER_IRDETO 1
-#define READER_CONAX 1
-#define READER_CRYPTOWORKS 1
-#define READER_SECA 1
-#define READER_VIACCESS 1
-#define READER_VIDEOGUARD 1
-#define READER_DRE 1
-#define READER_TONGFANG 1
-#define READER_BULCRYPT 1
-#define READER_GRIFFIN 1
-#define READER_DGCRYPT 1
+//#define READER_NAGRA 1
+//#define READER_IRDETO 1
+//#define READER_CONAX 1
+//#define READER_CRYPTOWORKS 1
+//#define READER_SECA 1
+//#define READER_VIACCESS 1
+//#define READER_VIDEOGUARD 1
+//#define READER_DRE 1
+//#define READER_TONGFANG 1
+//#define READER_BULCRYPT 1
+//#define READER_GRIFFIN 1
+//#define READER_DGCRYPT 1
 
-#define CARDREADER_PHOENIX 1
-#define CARDREADER_INTERNAL 1
-#define CARDREADER_MP35 1
-#define CARDREADER_SC8IN1 1
-#define CARDREADER_SMARGO 1
-#define CARDREADER_DB2COM 1
-#define CARDREADER_STINGER 1
+//#define CARDREADER_PHOENIX 1
+//#define CARDREADER_INTERNAL 1
+//#define CARDREADER_MP35 1
+//#define CARDREADER_SC8IN1 1
+//#define CARDREADER_SMARGO 1
+//#define CARDREADER_DB2COM 1
+//#define CARDREADER_STINGER 1
 
 #ifdef WITH_PCSC
 #define CARDREADER_PCSC 1
@@ -75,7 +76,7 @@
 #endif
 
 #ifdef WITH_STAPI
-#define CARDREADER_STAPI 1
+//#define CARDREADER_STAPI 1
 #endif
 
 #endif // WITH_CARDREADER
Index: modules.h
===================================================================
--- a/modules.h	(revision 8984)
+++ b/modules.h	(working copy)
@@ -13,6 +13,7 @@
 void module_ghttp(struct s_module *);
 void module_gbox(struct s_module *);
 void module_constcw(struct s_module *);
+void module_mcas(struct s_module *);
 void module_csp(struct s_module *);
 void module_dvbapi(struct s_module *);
 
Index: Makefile
===================================================================
--- a/Makefile	(revision 8984)
+++ b/Makefile	(working copy)
@@ -30,7 +30,6 @@
 	override USE_LIBCRYPTO=1
 endif
 
-CONF_DIR = /usr/local/etc
 
 LIB_PTHREAD = -lpthread
 LIB_DL = -ldl
@@ -48,8 +47,6 @@
 # Compiler optimizations
 CC_OPTS = -O2 -ggdb -pipe -ffunction-sections -fdata-sections
 
-CC = $(CROSS_DIR)$(CROSS)gcc
-STRIP = $(CROSS_DIR)$(CROSS)strip
 
 LDFLAGS = -Wl,--gc-sections
 
@@ -220,6 +217,7 @@
 SRC-$(CONFIG_MODULE_CCCAM) += module-cccam.c
 SRC-$(CONFIG_MODULE_CCCSHARE) += module-cccshare.c
 SRC-$(CONFIG_MODULE_CONSTCW) += module-constcw.c
+SRC-$(CONFIG_MODULE_MCAS) += module-mcas.c
 SRC-$(CONFIG_CS_CACHEEX) += module-csp.c
 SRC-$(CONFIG_CW_CYCLE_CHECK) += module-cw-cycle-check.c
 SRC-$(CONFIG_WITH_AZBOX) += module-dvbapi-azbox.c
Index: oscam-config-account.c
===================================================================
--- a/oscam-config-account.c	(revision 8984)
+++ b/oscam-config-account.c	(working copy)
@@ -93,6 +93,7 @@
 				// these have no listener ports so it doesn't make sense
 				else if(streq(ptr, "dvbapi"))   { account->allowedprotocols |= LIS_DVBAPI; }
 				else if(streq(ptr, "constcw"))  { account->allowedprotocols |= LIS_CONSTCW; }
+				else if(streq(ptr, "mcas"))  { account->allowedprotocols |= LIS_CONSTCW; }
 				else if(streq(ptr, "serial"))   { account->allowedprotocols |= LIS_SERIAL; }
 			}
 		}
Index: oscam-reader.c
===================================================================
--- a/oscam-reader.c	(revision 8984)
+++ b/oscam-reader.c	(working copy)
@@ -1052,12 +1052,16 @@
 		return;
 	}
 
+#if WITH_CARDREADER == 1
 	cardreader_process_ecm(reader, cl, er);  // forward request to physical reader
+#endif
 }
 
 void reader_do_card_info(struct s_reader *reader)
 {
+#if WITH_CARDREADER == 1
 	cardreader_get_card_info(reader);
+#endif
 	if(reader->ph.c_card_info)
 		{ reader->ph.c_card_info(); }
 }
@@ -1141,7 +1145,9 @@
 	}
 	else
 	{
+#if WITH_CARDREADER == 1
 		if(!cardreader_init(reader))
+#endif
 			{ return 0; }
 	}
 
@@ -1363,8 +1369,9 @@
 	cs_writelock(&system_lock);
 	struct s_reader *rdr;
 
+#if WITH_CARDREADER == 1
 	cardreader_init_locks();
-
+#endif
 	LL_ITER itr = ll_iter_create(configured_readers);
 	while((rdr = ll_iter_next(&itr)))
 	{
Index: oscam-ecm.c
===================================================================
--- a/oscam-ecm.c	(revision 8984)
+++ b/oscam-ecm.c	(working copy)
@@ -1621,7 +1621,9 @@
 				reader->resetcounter = 0;
 				rdr_log(reader, "Resetting reader, resetcyle of %d ecms reached", reader->resetcycle);
 				reader->card_status = CARD_NEED_INIT;
+#if WITH_CARDREADER == 1
 				cardreader_reset(cl);
+#endif
 			}
 		}
 	}
Index: module-dvbapi.c
===================================================================
--- a/module-dvbapi.c	(revision 8984)
+++ b/module-dvbapi.c	(working copy)
@@ -21,6 +21,47 @@
 #include "oscam-time.h"
 #include "reader-irdeto.h"
 
+#ifdef DVBAPI_SAMYGO
+static int _ioctl(int fd, int request, ...)
+{
+    typedef struct dmx_sct_filter_params dmx_sct_filter_params_t;
+    typedef struct dmxSctFilterParams dmxSctFilterParams_t;
+    va_list ap;
+    va_start(ap, request);
+    int ret = -1;
+    switch(request)
+    {
+    case DMX_SET_FILTER:
+        {
+            dmx_sct_filter_params_t *sFP2 = va_arg(ap, dmx_sct_filter_params_t*);
+			unsigned char packet[sizeof(request) + sizeof(dmx_sct_filter_params_t)];
+			memcpy(&packet, &request, sizeof(request));
+			memcpy(&packet[sizeof(request)], sFP2, sizeof(dmx_sct_filter_params_t));
+            ret = send(fd, packet, sizeof(packet), 0);
+        }
+        break;
+    case DMX_SET_FILTER1:
+        {
+            dmxSctFilterParams_t *sFP1 = va_arg(ap, dmxSctFilterParams_t*);
+            ret = send(fd, sFP1, sizeof(dmxSctFilterParams_t), 0);
+        }
+        break;
+    case DMX_STOP:
+        {
+            ret = send(fd, &request, sizeof(request), 0);
+            ret = 1;
+        }
+        break;
+    default:
+		cs_log("ERROR: Invalid ioctl request");
+    }
+    va_end(ap);
+    if(ret > 0)
+        ret = 1;
+    return ret;
+}
+#define ioctl _ioctl
+#endif
 // tunemm_caid_map
 #define FROM_TO 0
 #define TO_FROM 1
@@ -425,12 +466,22 @@
 	else
 	{
 		cs_log("ERROR: Could not start demux filter (api: %d errno=%d %s)", selected_api, errno, strerror(errno));
+		dvbapi_stop_descrambling(demux_id);
+        close(demux[demux_id].demux_fd[n].fd);
+        demux[demux_id].demux_fd[n].fd = -1;
 	}
 	return ret;
 }
 
 static int32_t dvbapi_detect_api(void)
 {
+#ifdef DVBAPI_SAMYGO
+	selected_api = DVBAPI_3;
+	selected_box = 0;
+	disable_pmt_files = 1;
+	cs_log("Using SamyGO dvbapi v0.1.1 (c) bugficks 2013");
+	return 1;
+#endif
 #ifdef WITH_COOLAPI
 	selected_api = COOLAPI;
 	selected_box = 5;
@@ -438,13 +489,13 @@
 	cs_log("Detected Coolstream API");
 	return 1;
 #else
-	int32_t i, devnum = -1, dmx_fd = 0, boxnum = sizeof(devices) / sizeof(struct box_devices);
+	int32_t i = 0, n = 0, devnum = -1, dmx_fd = 0, boxnum = sizeof(devices) / sizeof(struct box_devices);
 	char device_path[128], device_path2[128];
 
-	for(i = 0; i < boxnum; i++)
+	while (i < boxnum)
 	{
 		snprintf(device_path2, sizeof(device_path2), devices[i].demux_device, 0);
-		snprintf(device_path, sizeof(device_path), devices[i].path, 0);
+		snprintf(device_path, sizeof(device_path), devices[i].path, n);
 		strncat(device_path, device_path2, sizeof(device_path) - strlen(device_path) - 1);
 		if((dmx_fd = open(device_path, O_RDWR | O_NONBLOCK)) > 0)
 		{
@@ -453,6 +504,7 @@
 			if(ret < 0) { cs_log("ERROR: Could not close demuxer fd (errno=%d %s)", errno, strerror(errno)); }
 			break;
 		}
+		if ((strchr(devices[i].path, '%') != NULL) && (n < 8)) n++; else { n = 0; i++; }
 	}
 
 	if(devnum == -1) { return 0; }
@@ -529,11 +581,24 @@
 		strncat(device_path, device_path2, sizeof(device_path) - strlen(device_path) - 1);
 	}
 
+#ifdef DVBAPI_SAMYGO
+	struct sockaddr_un saddr;
+    memset(&saddr, 0, sizeof(saddr));
+	saddr.sun_family = AF_UNIX;
+	strncpy(saddr.sun_path, device_path, sizeof(saddr.sun_path) - 1);
+    dmx_fd = socket(AF_UNIX, SOCK_STREAM, 0);
+    if(connect(dmx_fd, (struct sockaddr *)&saddr, sizeof(saddr)) < 0)
+    {
+		cs_log("ERROR: Can't open device %s (errno=%d %s)", device_path, errno, strerror(errno));
+        dmx_fd = -1;
+    }
+#else
 	if((dmx_fd = open(device_path, O_RDWR | O_NONBLOCK)) < 0)
 	{
 		cs_log("ERROR: Can't open device %s (errno=%d %s)", device_path, errno, strerror(errno));
 		return -1;
 	}
+#endif
 
 	cs_debug_mask(D_DVBAPI, "DEVICE open (%s) fd %d", device_path, dmx_fd);
 
@@ -1359,7 +1424,7 @@
 				er->ecmlen += 2;
 			}
 
-			cs_log("[DVBAPI] Demuxer #%d trying to descramble PID #%d CAID %04X PROVID %06X ECMPID %04X ANY CHID VPID %04X", demux_id, pid,
+			cs_debug_mask(D_DVBAPI, "[DVBAPI] Demuxer #%d trying to descramble PID #%d CAID %04X PROVID %06X ECMPID %04X ANY CHID VPID %04X", demux_id, pid,
 				   demux[demux_id].ECMpids[pid].CAID, demux[demux_id].ECMpids[pid].PROVID, demux[demux_id].ECMpids[pid].ECM_PID,
 				   demux[demux_id].ECMpids[pid].VPID);
 
@@ -1383,13 +1448,13 @@
 
 			if(p && p->chid < 0x10000)  // do we prio a certain chid?
 			{
-				cs_log("[DVBAPI] Demuxer #%d trying to descramble PID #%d CAID %04X PROVID %06X ECMPID %04X CHID %04X VPID %04X", demux_id, pid,
+				cs_debug_mask(D_DVBAPI, "[DVBAPI] Demuxer #%d trying to descramble PID #%d CAID %04X PROVID %06X ECMPID %04X CHID %04X VPID %04X", demux_id, pid,
 					   demux[demux_id].ECMpids[pid].CAID, demux[demux_id].ECMpids[pid].PROVID, demux[demux_id].ECMpids[pid].ECM_PID,
 					   demux[demux_id].ECMpids[pid].CHID, demux[demux_id].ECMpids[pid].VPID);
 			}
 			else
 			{
-				cs_log("[DVBAPI] Demuxer #%d trying to descramble PID #%d CAID %04X PROVID %06X ECMPID %04X ANY CHID VPID %04X", demux_id, pid,
+				cs_debug_mask(D_DVBAPI, "[DVBAPI] Demuxer #%d trying to descramble PID #%d CAID %04X PROVID %06X ECMPID %04X ANY CHID VPID %04X", demux_id, pid,
 					   demux[demux_id].ECMpids[pid].CAID, demux[demux_id].ECMpids[pid].PROVID, demux[demux_id].ECMpids[pid].ECM_PID,
 					   demux[demux_id].ECMpids[pid].VPID);
 			}
@@ -1652,7 +1717,7 @@
 		entry->ecmpid = ecmpid;
 		entry->chid = chid;
 
-		uint32_t delay = 0, force = 0, mapcaid = 0, mapprovid = 0, mapecmpid = 0;
+		uint32_t delay = 0, force = 0, mapcaid = 0, mapprovid = 0, mapecmpid = 0, mapsrvid = 0;
 		switch(type)
 		{
 		case 'd':
@@ -1668,9 +1733,10 @@
 			entry->force = force;
 			break;
 		case 'm':
-			sscanf(str1 + 64, "%4x:%6x", &mapcaid, &mapprovid);
+            sscanf(str1 + 64, "%4x:%6x:%4x", &mapcaid, &mapprovid, &mapsrvid);
 			entry->mapcaid = mapcaid;
 			entry->mapprovid = mapprovid;
+			entry->srvid = mapsrvid;
 			break;
 		case 'a':
 		case 'j':
@@ -2298,7 +2364,7 @@
 	uint32_t program_info_length = ((buffer[4] & 0x0F) << 8) | buffer[5];
 
 	cs_ddump_mask(D_DVBAPI, buffer, length, "capmt:");
-	cs_log("[DVBAPI] Receiver sends PMT command %d for channel %04X", ca_pmt_list_management, program_number);
+	cs_debug_mask(D_DVBAPI, "[DVBAPI] Receiver sends PMT command %d for channel %04X", ca_pmt_list_management, program_number);
 	if((ca_pmt_list_management == LIST_FIRST || ca_pmt_list_management == LIST_ONLY) && pmt_stopmarking == 0)
 	{
 		for(i = 0; i < MAX_DEMUX; i++)
@@ -2323,14 +2389,14 @@
 		{
 #endif
 			getDemuxOptions(i, buffer, &ca_mask, &demux_index, &adapter_index);
-			cs_log("[DVBAPI] Receiver wants to demux srvid %04X on adapter %04X camask %04X index %04X", program_number, adapter_index, ca_mask, demux_index);
+			cs_debug_mask(D_DVBAPI, "[DVBAPI] Receiver wants to demux srvid %04X on adapter %04X camask %04X index %04X", program_number, adapter_index, ca_mask, demux_index);
 
 			if(ca_pmt_list_management == LIST_UPDATE || ca_pmt_list_management == LIST_LAST)   //PMT Update */
 			{
 
 				if(demux[i].adapter_index != adapter_index || demux[i].demux_index != demux_index)
 				{
-					cs_log("[DVBAPI] Demuxer #%d PMT update for decoding of SRVID %04X on additional demuxer! ", i, program_number);
+					cs_debug_mask(D_DVBAPI, "[DVBAPI] Demuxer #%d PMT update for decoding of SRVID %04X on additional demuxer! ", i, program_number);
 					demux[i].stopdescramble = 0;
 				}
 				else
@@ -2346,7 +2412,7 @@
 					demux[demux_id].EMMpidcount = 0;
 					demux[i].stopdescramble = 0;
 					running = 1;
-					cs_log("[DVBAPI] Demuxer #%d PMT update for decoding of SRVID %04X", i, program_number);
+					cs_debug_mask(D_DVBAPI, "[DVBAPI] Demuxer #%d PMT update for decoding of SRVID %04X", i, program_number);
 				}
 			}
 
@@ -2355,7 +2421,7 @@
 				demux_id = i;
 				if(demux[demux_id].adapter_index == adapter_index && demux[demux_id].demux_index == demux_index)
 				{
-					cs_log("[DVBAPI] Demuxer #%d continue decoding of SRVID %04X", i, demux[i].program_number);
+					cs_debug_mask(D_DVBAPI, "[DVBAPI] Demuxer #%d continue decoding of SRVID %04X", i, demux[i].program_number);
 #if defined WITH_AZBOX || defined WITH_MCA
 					openxcas_sid = program_number;
 #endif
@@ -2588,7 +2654,7 @@
 	dvbapi_client->last_srvid = demux[demux_id].program_number;
 	dvbapi_client->last_caid = 0;
 // reset idle-Time
-	dvbapi_client->last = time((time_t *)0);
+	dvbapi_client->lastswitch = dvbapi_client->last = time((time_t *)0);
 
 #if defined WITH_AZBOX || defined WITH_MCA
 	openxcas_sid = program_number;
@@ -2608,6 +2674,19 @@
 {
 	uint32_t val = 0, size = 0, i, k;
 	pmt_stopmarking = 0; // to stop_descrambling marking in PMT 6 mode
+#ifdef DVBAPI_SAMYGO
+    if(buffer && buffer[0] == 2)
+    {
+        uchar dest[1024];
+        memcpy(dest, "\x03\xFF\xFF\x00\x00\x13\x00", 7);
+        dest[1] = buffer[3];
+        dest[2] = buffer[4];
+        dest[5] = buffer[11] + 1;
+        memcpy(dest + 7, buffer + 12, len - 12 - 4);
+	    dvbapi_parse_capmt(dest, 7 + len - 12 - 4, connfd, NULL);
+        return;
+    }
+#endif
 
 	for(k = 0; k < len; k += 3 + size + val)
 	{
@@ -2964,6 +3043,7 @@
 
 	if(demux[demux_id].demux_fd[filter_num].type == TYPE_ECM)
 	{
+		cs_debug_mask(D_DVBAPI, "[DVBAPI] Demuxer #%d Filter #%d fetched ecm data", demux_id, filter_num + 1);
 		if(len != (((buffer[1] & 0xf) << 8) | buffer[2]) + 3)   // invalid CAT length
 		{
 			cs_debug_mask(D_DVBAPI, "[DVBAPI] Received an ECM with invalid CAT length!");
@@ -3793,8 +3873,6 @@
 		cs_debug_mask(D_DVBAPI, "[DVBAPI] Demuxer #%d %scontrolword received for PID #%d CAID %04X PROVID %06X ECMPID %04X CHID %04X VPID %04X", i,
 					  (er->rc >= E_NOTFOUND ? "no " : ""), j, er->caid, er->prid, er->pid, er->chid, er->vpid);
 
-		if(er->rc < E_NOTFOUND)   // check for delayed response on already expired ecmrequest
-		{
 			uint32_t status = dvbapi_check_ecm_delayed_delivery(i, er);
 
 			uint32_t comparecw0 = 0, comparecw1 = 0;
@@ -3838,7 +3916,7 @@
 			{
 				cs_debug_mask(D_DVBAPI, "[DVBAPI] Demuxer #%d new controlword from cache-ex reader (no ecmhash check possible)", i);
 			}
-		}
+		
 		handled = 1; // mark this ecm response as handled
 		if(er->rc < E_NOTFOUND && cfg.dvbapi_requestmode == 0 && (demux[i].pidindex == -1) && er->caid != 0)
 		{
@@ -4110,6 +4188,8 @@
 {
 
 	if(!er) { return -1; }
+#ifdef DVBAPI_SAMYGO
+#endif
 
 	if(selected_api != DVBAPI_3 && selected_api != DVBAPI_1 && selected_api != STAPI)   // only valid for dvbapi3, dvbapi1 and STAPI
 	{
Index: utils/list_smargo.c
===================================================================
--- a/utils/list_smargo.c	(revision 8984)
+++ b/utils/list_smargo.c	(working copy)
@@ -42,6 +42,7 @@
 	int32_t busid, devid;
 	unsigned char iserialbuffer[128], iproductbuffer[128];
 	char *productptr = (char *)iproductbuffer;
+	static const char *const typename_str[6] = {"SR", "Infinity", "SRv2", "TripleP1", "TripleP2", "TripleP3"};
 
 	nb_endpoint_ok = 0;
 
@@ -62,7 +63,7 @@
 		for(m = 0; m < sizeof(reader_types) / sizeof(struct s_reader_types); ++m)
 		{
 			nb_endpoint_ok = 0;
-			for(j = 0; j < configDesc->bNumInterfaces; j++)
+			for(j = 0; j < (configDesc->bNumInterfaces); j++)
 			{
 				for(k = 0; k < configDesc->interface[j].num_altsetting; k++)
 				{
@@ -76,6 +77,7 @@
 					}
 				}
 			}
+			if ((usbdesc.idProduct = 0x6011) && (m == 2)) nb_endpoint_ok = 0;
 			if(nb_endpoint_ok == 2)
 			{
 				busid = libusb_get_bus_number(usb_dev);
@@ -87,8 +89,8 @@
 				printf("bus %03d, device %03d : %04x:%04x %s (type=%s, in_ep=%02x, out_ep=%02x; insert in oscam.server 'device = %s%sSerial:%s')\n",
 					   busid, devid,
 					   usbdesc.idVendor, usbdesc.idProduct, strlen(productptr) > 0 ? productptr : "Smartreader",
-					   reader_types[m].name, reader_types[m].in_ep, reader_types[m].out_ep,
-					   strcmp(reader_types[m].name, "SR") ? reader_types[m].name : "", strcmp(reader_types[m].name, "SR") ? ";" : "", iserialbuffer
+					   typename_str[reader_types[m].rdrtypename], reader_types[m].in_ep, reader_types[m].out_ep,
+					   reader_types[m].rdrtypename == 0 ? "" : typename_str[reader_types[m].rdrtypename] , reader_types[m].rdrtypename == 0 ? "" : ";", iserialbuffer
 					  );
 			}
 		}
Index: module-webif.c
===================================================================
--- a/module-webif.c	(revision 8984)
+++ b/module-webif.c	(working copy)
@@ -1086,6 +1086,7 @@
 	if(cfg.http_refresh > 0)
 	{
 		tpl_printf(vars, TPLADD, "REFRESHTIME", "%d", cfg.http_refresh);
+		tpl_addVar(vars, TPLADD, "REFRESHURL", "readers.html");
 		tpl_addVar(vars, TPLADD, "REFRESH", tpl_getTpl(vars, "REFRESH"));
 	}
 	if((strcmp(getParam(params, "action"), "disable") == 0) || (strcmp(getParam(params, "action"), "enable") == 0))
@@ -5633,6 +5634,7 @@
 	if(cfg.http_refresh > 0)
 	{
 		tpl_printf(vars, TPLADD, "REFRESHTIME", "%d", cfg.http_refresh);
+		tpl_addVar(vars, TPLADD, "REFRESHURL", "cacheex.html");
 		tpl_addVar(vars, TPLADD, "REFRESH", tpl_getTpl(vars, "REFRESH"));
 	}
 	char *level[] = {"NONE", "CACHE PULL", "CACHE PUSH", "REVERSE CACHE PUSH"};
Index: reader-irdeto.c
===================================================================
--- a/reader-irdeto.c	(revision 8984)
+++ b/reader-irdeto.c	(working copy)
@@ -548,7 +548,7 @@
 		}
 		break;
 	}
-	if(reader->cardmhz != 600)
+	if((reader->cardmhz != 600 && reader->typ != R_INTERNAL) || (reader->typ == R_INTERNAL && (reader->cardmhz<510 || reader->cardmhz>690)))
 		{ rdr_log(reader, "WARNING: For Irdeto cards you will have to set 'cardmhz = 600' in oscam.server"); }
 
 	return irdeto_card_init_provider(reader);
Index: reader-common.c
===================================================================
--- a/reader-common.c	(revision 8984)
+++ b/reader-common.c	(working copy)
@@ -104,7 +104,7 @@
 	if(ret) { return (0); }
 
 	//  rdr_log("ATR: %s", cs_hexdump(1, atr, atr_size, tmp, sizeof(tmp)));//FIXME
-	cs_sleepms(1000);
+	cs_sleepms(500);
 	return (1);
 }
 
@@ -163,7 +163,7 @@
 	int32_t ret = 0;
 	int16_t i = 0;
 	int16_t j = 0;
-	if (reader->typ == R_SMART && reader->smartdev_found >= 2) j = 2; else j = 1; // we will do two full start attempts for triple
+	if (reader->typ == R_SMART && reader->smartdev_found >= 3) j = 3; else j = 1; // we will do Three full start attempts for triple an v2
 
 	for (i= 0; i < j; i++) {
 
@@ -176,7 +176,7 @@
 		{
 			uint16_t y;
 			uint16_t deprecated;
-			if (reader->typ == R_SMART ) y = 2; else y= 2;
+			if (reader->typ == R_SMART && reader->smartdev_found >= 3) y = 3; else y= 2;
 //			rdr_log(reader, "the restart atempts in deprecated is %u", y);
 			for(deprecated = reader->deprecated; deprecated < y; deprecated++)
 			{
@@ -305,9 +305,9 @@
 	}
 	else
 	{
-/*		if (reader->typ == R_SMART ){
+		if (reader->typ == R_SMART ){
 			rdr_log(reader, "clocking for smartreader with smartreader protocol");
-			if (reader->cardmhz == 357) reader->cardmhz = 369; // 357 is not a default or supported by smartreader
+/*			if (reader->cardmhz <= 357) reader->cardmhz = 369; // 357 is not a default or supported by smartreader
 			if (reader->mhz >= 1600) reader->mhz = 1600; else
 			if (reader->mhz >= 1200) reader->mhz = 1200; else
 			if (reader->mhz >= 961)  reader->mhz =  961; else
@@ -320,8 +320,8 @@
 			if (reader->mhz >= 400)  reader->mhz =  400; else
 			if (reader->mhz >= 357)  reader->mhz =  369; else
 			if (reader->mhz >= 343)  reader->mhz =  343; else 
-			reader->mhz =  320;
-	    } this seems to do nothing for v2 or triple and for v1 not needed */
+			reader->mhz =  320;*/
+	    } 
 		rdr_log(reader, "Reader initialized (device=%s, detect=%s%s, mhz=%d, cardmhz=%d)",
 				reader->device,
 				reader->detect & 0x80 ? "!" : "",
Index: csctapi/ifd_smartreader_types.h
===================================================================
--- a/csctapi/ifd_smartreader_types.h	(revision 8984)
+++ b/csctapi/ifd_smartreader_types.h	(working copy)
@@ -64,6 +64,15 @@
 enum smartreader_break_type { BREAK_OFF = 0, BREAK_ON = 1 };
 
 /** Port interface for chips with multiple interfaces */
+enum smartreader_rdrtypename 
+{
+	SR			= 0,
+	Infinity	= 1,
+	SRv2		= 2,
+	TripleP1	= 3,
+	TripleP2	= 4,
+	TripleP3	= 5
+};
 enum smartreader_interface
 {
 	INTERFACE_ANY = 0,
@@ -75,7 +84,7 @@
 
 struct s_reader_types
 {
-	char *name;
+	uint16_t rdrtypename;
 	uint8_t in_ep;
 	uint8_t out_ep;
 	int32_t index;
@@ -84,12 +93,12 @@
 
 const struct s_reader_types reader_types[] =
 {
-	{"SR", 0x01, 0x82, INTERFACE_A, 0},
-	{"SRv2", 0x02, 0x81, INTERFACE_A, 0},
-	{"Infinity", 0x01, 0x81, INTERFACE_A, 0},
-	{"TripleP1", 0x02, 0x81, INTERFACE_A, 0},
-	{"TripleP2", 0x04, 0x83, INTERFACE_B, 1},
-	{"TripleP3", 0x06, 0x85, INTERFACE_C, 2}
+	{ SR, 0x01, 0x82, INTERFACE_A, 0},			//  type 0
+	{ Infinity, 0x01, 0x81, INTERFACE_A, 0},	//  type 1
+	{ SRv2, 0x02, 0x81, INTERFACE_A, 0},		//  type 2
+	{ TripleP1, 0x02, 0x81, INTERFACE_A, 0},	//  type 3
+	{ TripleP2, 0x04, 0x83, INTERFACE_B, 1},	//  type 4
+	{ TripleP3, 0x06, 0x85, INTERFACE_C, 2}		// type 5
 };
 
 #endif // __SMARTREADER_TYPES_H__
Index: csctapi/ifd_smartreader.c
===================================================================
--- a/csctapi/ifd_smartreader.c	(revision 8984)
+++ b/csctapi/ifd_smartreader.c	(working copy)
@@ -31,9 +31,10 @@
 #define LOBYTE(w) ((unsigned char)((w) & 0xff))
 #define HIBYTE(w) ((unsigned char)((w) >> 8))
 
-#define NUM_TXFERS 1
-static CS_MUTEX_LOCK sr_lock;
+#define NUM_TXFERS 2
 
+static const char *const rdrtype_str[6] = {"SR","Infinity", "SRv2", "TripleP1", "TripleP2", "TripleP3"};
+
 struct sr_data
 {
 	int32_t F;
@@ -48,6 +49,7 @@
 	libusb_device *usb_dev;
 	libusb_device_handle *usb_dev_handle;
 	enum smartreader_chip_type type;
+	enum smartreader_rdrtypename rdrtype;
 	uint8_t in_ep;
 	uint8_t out_ep;
 	int32_t index;
@@ -57,7 +59,7 @@
 	int32_t usb_write_timeout;
 	uint32_t  writebuffer_chunksize;
 	unsigned char bitbang_enabled;
-	int baudrate2;
+	int baudrate;
 	int32_t interface;   // 0 ,1 or 2
 	/** maximum packet size. Needed for filtering modem status bytes every n packets. */
 	uint32_t  max_packet_size;
@@ -70,6 +72,8 @@
 	int32_t poll;
 	pthread_t rt;
 	unsigned char modem_status;
+	uint16_t tripledelay;
+	int detectstart ;
 };
 
 static int32_t init_count;
@@ -144,7 +148,7 @@
 		if(ret < 0)
 		{
 			rdr_log(reader, "usb bulk write failed : ret = %d", ret);
-			cs_writeunlock(&sr_lock);
+			cs_writeunlock(&reader->sr_lock);
 			return (ret);
 		}
 		rdr_ddump_mask(reader, D_DEVICE, buff + offset, written, "SR: Transmit:");
@@ -253,10 +257,12 @@
 					{
 						cs_log("Found reader with serial %s at %03d:%03d", dev_name, libusb_get_bus_number(dev), libusb_get_device_address(dev));
 						if(smartreader_check_endpoint(dev, in_endpoint, out_endpoint)) {
-							if(out_endpoint == 0x82) rdr->smartdev_found = 1 ;  else
-							if(out_endpoint == 0x81) rdr->smartdev_found = 2 ; else
-							if(out_endpoint == 0x83) rdr->smartdev_found = 3 ; else
-							if(out_endpoint == 0x85) rdr->smartdev_found = 4 ; else
+							if(out_endpoint == 0x82 && in_endpoint == 0x01 && usbdesc.idProduct == 0x6001) { rdr->smart_type = 0; rdr->smartdev_found = 1;} else
+							if(out_endpoint == 0x81 && in_endpoint == 0x01) { rdr->smart_type = 1; rdr->smartdev_found = 2;} else
+							if(out_endpoint == 0x81 && in_endpoint == 0x02 && usbdesc.idProduct == 0x6001) { rdr->smart_type = 2; rdr->smartdev_found = 3;} else
+							if(out_endpoint == 0x81 && in_endpoint == 0x02 && usbdesc.idProduct == 0x6011) { rdr->smart_type = 3; rdr->smartdev_found = 4;} else
+							if(out_endpoint == 0x83 && in_endpoint == 0x04 && usbdesc.idProduct == 0x6011) { rdr->smart_type = 4; rdr->smartdev_found = 5;} else
+							if(out_endpoint == 0x85 && in_endpoint == 0x06 && usbdesc.idProduct == 0x6011) { rdr->smart_type = 5; rdr->smartdev_found = 6;} else
 								rdr->smartdev_found = 0;
 						} 
 					}
@@ -266,12 +272,13 @@
 			{
 				cs_debug_mask(D_DEVICE, "SR: Checking FTDI device: %03d on bus %03d", libusb_get_device_address(dev), libusb_get_bus_number(dev));
 				// check for smargo endpoints.
-				if(smartreader_check_endpoint(dev, in_endpoint, out_endpoint))
 						if(smartreader_check_endpoint(dev, in_endpoint, out_endpoint)) {
-							if(out_endpoint == 0x82) rdr->smartdev_found = 1 ; else
-							if(out_endpoint == 0x81) rdr->smartdev_found = 2 ; else
-							if(out_endpoint == 0x83) rdr->smartdev_found = 3 ; else
-							if(out_endpoint == 0x85) rdr->smartdev_found = 4 ; else
+							if(out_endpoint == 0x82 && in_endpoint == 0x01 && usbdesc.idProduct == 0x6001) { rdr->smart_type = 0; rdr->smartdev_found = 1;} else
+							if(out_endpoint == 0x81 && in_endpoint == 0x01) { rdr->smart_type = 1; rdr->smartdev_found = 2;} else
+							if(out_endpoint == 0x81 && in_endpoint == 0x02 && usbdesc.idProduct == 0x6001) { rdr->smart_type = 2; rdr->smartdev_found = 3;} else
+							if(out_endpoint == 0x81 && in_endpoint == 0x02 && usbdesc.idProduct == 0x6011) { rdr->smart_type = 3; rdr->smartdev_found = 4;} else
+							if(out_endpoint == 0x83 && in_endpoint == 0x04 && usbdesc.idProduct == 0x6011) { rdr->smart_type = 4; rdr->smartdev_found = 5;} else
+							if(out_endpoint == 0x85 && in_endpoint == 0x06 && usbdesc.idProduct == 0x6011) { rdr->smart_type = 5; rdr->smartdev_found = 6;} else
 								rdr->smartdev_found = 0;
 						} 
 			}
@@ -293,27 +300,28 @@
 	return dev;
 }
 
-void smartreader_init(struct s_reader *reader, char *rdrtype)
+void smartreader_init(struct s_reader *reader)
 {
 	uint32_t i;
 	struct sr_data *crdr_data = reader->crdr_data;
 
 	crdr_data->usb_dev = NULL;
 	crdr_data->usb_dev_handle = NULL;
-	crdr_data->usb_read_timeout = 10000;
+	crdr_data->usb_read_timeout = 20000;
 	crdr_data->usb_write_timeout = 10000;
 
 	crdr_data->type = TYPE_BM;    /* chip type */
-	crdr_data->baudrate2 = -1;
+	crdr_data->baudrate = -1;
 	crdr_data->bitbang_enabled = 0;  /* 0: normal mode 1: any of the bitbang modes enabled */
 
 	crdr_data->writebuffer_chunksize = 4096;
 	crdr_data->max_packet_size = 0;
-	if(rdrtype)
+	rdr_log(reader,"initing smargo type %s", rdrtype_str[crdr_data->rdrtype]);
+	if(crdr_data->rdrtype)
 	{
 		for(i = 0; i < sizeof(reader_types) / sizeof(struct s_reader_types); ++i)
 		{
-			if(!strcasecmp(reader_types[i].name, rdrtype))
+			if(reader_types[i].rdrtypename == crdr_data->rdrtype)
 			{
 				crdr_data->in_ep = reader_types[i].in_ep;
 				crdr_data->out_ep = reader_types[i].out_ep;
@@ -322,7 +330,7 @@
 				return;
 			}
 		}
-		rdr_log(reader, "Smartreader: The defined reader type %s is unknown. Using default Smartreader values.", rdrtype);
+		rdr_log(reader, "Smartreader: The defined reader type %u is unknown. Using default Smartreader values.", crdr_data->rdrtype);
 	}
 	crdr_data->in_ep = 0x01;
 	crdr_data->out_ep = 0x82;
@@ -344,6 +352,7 @@
 	// Determine maximum packet size. Init with default value.
 	// New hi-speed devices from FTDI use a packet size of 512 bytes
 	// but could be connected to a normal speed USB hub -> 64 bytes packet size.
+	rdr_log(reader,"DE PACKET SIZE DETERMINATION USES READER TYPE %u", crdr_data->type);
 	if(crdr_data->type == TYPE_2232H || crdr_data->type == TYPE_4232H)
 		{ packet_size = 512; }
 	else
@@ -378,6 +387,7 @@
 		}
 	}
 
+	if (crdr_data->rdrtype >= 3) packet_size = 512;
 	return packet_size;
 }
 
@@ -704,7 +714,7 @@
     actual_baudrate = smartreader_convert_baudrate(baudrate, reader, &value, &idx);
     if (actual_baudrate <= 0) {
         rdr_log(reader, "Silly baudrate <= 0.");
-		return ERROR;
+		return (-1);
 	}
 
     // Check within tolerance (about 5%)
@@ -713,15 +723,20 @@
                 ? (actual_baudrate * 21 < baudrate * 20)
                 : (baudrate * 21 < actual_baudrate * 20))) {
         rdr_log(reader, "Unsupported baudrate. Note: bitbang baudrates are automatically multiplied by 4");
-		return ERROR;
+		return (-1);
 	}
-    if (libusb_control_transfer(crdr_data->usb_dev_handle, FTDI_DEVICE_OUT_REQTYPE,
-                                SIO_SET_BAUDRATE_REQUEST, value,
-                                idx, NULL, 0, crdr_data->usb_write_timeout) < 0) {
+    if (libusb_control_transfer(crdr_data->usb_dev_handle, 
+								FTDI_DEVICE_OUT_REQTYPE,
+                                SIO_SET_BAUDRATE_REQUEST, 
+								value,
+                                idx, 
+								NULL, 
+								0, 
+								crdr_data->usb_write_timeout) < 0) {
         rdr_log(reader, "Setting new baudrate failed");
-		return ERROR;
+		return (-2);
 	}
-    crdr_data->baudrate2 = actual_baudrate;
+    crdr_data->baudrate = baudrate;
     return 0;
 }
 
@@ -1062,7 +1077,7 @@
 	else if(usbdesc.bcdDevice == 0x200)
 		{ crdr_data->type = TYPE_AM; }
 	else if((usbdesc.bcdDevice == 0x500) && (usbdesc.idProduct == 0x6011))
-		{ crdr_data->type = TYPE_2232C; }
+		{ crdr_data->type = TYPE_4232H; }
 	else if((usbdesc.bcdDevice == 0x500) && (usbdesc.idProduct != 0x6011))
 		{ crdr_data->type = TYPE_2232C; }
 	else if(usbdesc.bcdDevice == 0x600)
@@ -1074,6 +1089,8 @@
 
 	// Determine maximum packet size
 	crdr_data->max_packet_size = smartreader_determine_max_packet_size(reader);
+	rdr_log(reader,"reader type is %u", crdr_data->type);
+	rdr_log(reader,"maw packet size is %u", crdr_data->max_packet_size);
 
 	if(smartreader_set_baudrate(reader, 9600) != 0)
 	{
@@ -1089,7 +1106,7 @@
 	return (0);
 }
 
-static void EnableSmartReader(struct s_reader *reader, int32_t clock_val, uint16_t  Fi, unsigned char Di, unsigned char Ni, unsigned char T, unsigned char inv, int32_t parity)
+static void EnableSmartReader(struct s_reader *reader, uint32_t baud_temp, int32_t clock_val, uint16_t  Fi, unsigned char Di, unsigned char Ni, unsigned char T, unsigned char inv, int32_t parity)
 {
 	struct sr_data *crdr_data = reader->crdr_data;
 	unsigned char FiDi[4];
@@ -1100,7 +1117,7 @@
 	unsigned char Invert[2];
 	unsigned char temp_T;
 
-	smartreader_set_baudrate(reader, 9600);
+	smartreader_set_baudrate(reader, baud_temp);
 	smartreader_setflowctrl(reader, 0);
 	smartreader_set_line_property(reader, (enum smartreader_bits_type) 5, STOP_BIT_2, NONE);
 
@@ -1161,13 +1178,12 @@
 //	cs_writelock(&sr_lock);
 	smartreader_set_line_property2(reader, BITS_8, STOP_BIT_2, parity, BREAK_ON);
 	//  send break for 350ms, also comes from JoePub debugging.
-	cs_sleepms(350);
+	cs_sleepms(400);
 	if(temp_T == 1)
 		{ smartreader_set_line_property2(reader, BITS_8, STOP_BIT_1, parity, BREAK_OFF); }
 	else
 		{ smartreader_set_line_property2(reader, BITS_8, STOP_BIT_2, parity, BREAK_OFF); }
 
-	cs_writeunlock(&sr_lock);
     
 	smart_flush(reader);
 }
@@ -1176,12 +1192,14 @@
 static void *ReaderThread(void *p)
 {
 	struct libusb_transfer *usbt[NUM_TXFERS];
-	unsigned char usb_buffers[NUM_TXFERS][64];
+//	unsigned char usb_buffers[NUM_TXFERS][512];
 	struct s_reader *reader;
-	int32_t ret, idx;
+	int32_t ret, idx, size;
 
 	reader = (struct s_reader *)p;
 	struct sr_data *crdr_data = reader->crdr_data;
+	if (crdr_data->rdrtype >= 3) size = 512; else size = 64;
+	unsigned char usb_buffers[NUM_TXFERS][size];
 	crdr_data->running = 1;
 
 	set_thread_name(__func__);
@@ -1193,7 +1211,7 @@
 								  crdr_data->usb_dev_handle,
 								  crdr_data->out_ep,
 								  usb_buffers[idx],
-								  64,
+								  size,
 								  (void *)(&read_callback),
 								  p,
 								  0);
@@ -1249,10 +1267,11 @@
 	rdr_log(reader, "De SR_init");
 	if(!busname)
 	{
-		rdrtype = NULL;
+		rdrtype = "SR";
 		memcpy(device, reader->device, strlen(reader->device) + 1);
 		busname = strtok_r(device, ":", &saveptr1);
 		dev = strtok_r(NULL, search, &saveptr1);
+		rdr_log(reader, "TYPE IS SET ON %s", rdrtype);
 	}
 
 	if(!busname || !dev)
@@ -1261,22 +1280,44 @@
 		return ERROR;
 	}
 
-	cs_writelock(&sr_lock);
+	cs_writelock(&reader->sr_lock);
 	if(!reader->crdr_data && !cs_malloc(&reader->crdr_data, sizeof(struct sr_data)))
 		{ return ERROR; }
 	struct sr_data *crdr_data = reader->crdr_data;
+	crdr_data->detectstart = 0;
+	crdr_data->tripledelay = 0;
+	if (!strcasecmp(rdrtype, "SR")) {
+			crdr_data->rdrtype = SR;			
+	}
+		if (!strcasecmp(rdrtype, "Infinity")) {
+			crdr_data->rdrtype = Infinity;			
+	}
+	if (!strcasecmp(rdrtype, "SRv2")) {
+			crdr_data->tripledelay = 0;
+			crdr_data->rdrtype = SRv2;			
+	}
+ 	if (!strcasecmp(rdrtype, "TripleP1")) {
+			crdr_data->tripledelay = 0;
+			crdr_data->rdrtype = TripleP1;
+	}
+	if (!strcasecmp(rdrtype, "TripleP2")) {
+			crdr_data->tripledelay = 0;
+			crdr_data->rdrtype = TripleP2;
+	}
+	if (!strcasecmp(rdrtype, "TripleP3")) {
+			crdr_data->tripledelay = 0;
+			crdr_data->rdrtype = TripleP3;
+	}
 
 	rdr_debug_mask(reader, D_DEVICE, "SR: Looking for device %s on bus %s", dev, busname);
-	if (reader->smartdev_found)
-		cs_sleepms(reader->smartdev_found);
-	smartreader_init(reader, rdrtype);
+	smartreader_init(reader);
 
 	if(!init_count)
 	{
 		ret = libusb_init(NULL);
 		if(ret < 0)
 		{
-			cs_writeunlock(&sr_lock);
+			cs_writeunlock(&reader->sr_lock);
 			rdr_log(reader, "Libusb init error : %d", ret);
 			return ret;
 		}
@@ -1291,7 +1332,7 @@
 		--init_count;
 		if(!init_count)
 			{ libusb_exit(NULL); }
-		cs_writeunlock(&sr_lock);
+		cs_writeunlock(&reader->sr_lock);
 		return ERROR;
 	}
 
@@ -1302,16 +1343,23 @@
 		--init_count;
 		if(!init_count)
 			{ libusb_exit(NULL); }
-		cs_writeunlock(&sr_lock);
+		cs_writeunlock(&reader->sr_lock);
 		rdr_log(reader, "unable to open smartreader device %s in bus %s endpoint in 0x%02X out 0x%02X (ret=%d)\n", dev, busname, crdr_data->in_ep, crdr_data->out_ep, ret);
 		return ERROR;
 	}
+	if (crdr_data->rdrtype >= 2) {
 
-	rdr_debug_mask(reader, D_DEVICE, "SR: Setting smartreader latency timer to 2ms");
+		cs_writeunlock(&reader->sr_lock);
+		rdr_log(reader, "I'M SLEEPING FOR %u ms", crdr_data->tripledelay);
+		cs_sleepms(crdr_data->tripledelay);
+		cs_writelock(&reader->sr_lock);
+		rdr_debug_mask(reader, D_DEVICE, "SR: Setting smartreader latency timer to 2 ms");
+		ret = smartreader_set_latency_timer(reader, 2);
+	} else {
+		rdr_debug_mask(reader, D_DEVICE, "SR: Setting smartreader latency timer to 1 ms");
+		ret = smartreader_set_latency_timer(reader, 1);
+	}
 
-	//Set the FTDI latency timer to 16ms
-	ret = smartreader_set_latency_timer(reader, 16);
-
 	//Set databits to 8o2
 	ret = smartreader_set_line_property(reader, BITS_8, STOP_BIT_2, ODD);
 
@@ -1329,7 +1377,7 @@
 	pthread_mutex_init(&crdr_data->g_usb_mutex, NULL);
 	pthread_cond_init(&crdr_data->g_usb_cond, NULL);
 
-	cs_writeunlock(&sr_lock);
+	cs_writeunlock(&reader->sr_lock);
 	rdr_log(reader," Pthread Wordt gecreeerd");
 	ret = pthread_create(&crdr_data->rt, NULL, ReaderThread, (void *)(reader));
 	if(ret)
@@ -1344,27 +1392,29 @@
 {
 	struct sr_data *crdr_data = reader->crdr_data;
 	unsigned char data[ATR_MAX_SIZE];
+	uint32_t baud_temp;
 	int32_t ret;
 	int32_t atr_ok;
-	uint32_t  i;
+	int32_t  i;
 	int32_t parity[4] = {EVEN, ODD, NONE, EVEN};    // the last EVEN is to try with different F, D values for irdeto card.
 	static const char *const parity_str[5] = {"NONE", "ODD", "EVEN", "MARK", "SPACE"};
 	rdr_log(reader," SR_reset wordt gerund");
 
 	if(reader->mhz == reader->cardmhz && reader->cardmhz * 10000 > 3690000)
 		{ crdr_data->fs = reader->cardmhz * 10000; }
-	else
-		{ crdr_data->fs = 3690000; }
-
+	else {
+		if (crdr_data->rdrtype >= 2) crdr_data->fs = reader->cardmhz * 10000; 
+		else crdr_data->fs = reader->cardmhz * 10000;
+		}
 //	cs_writelock(&sr_lock);
 	smart_fastpoll(reader, 1);
-	smart_flush(reader);
 	// set smartreader+ default values
 	crdr_data->F = 372;
 	crdr_data->D = 1;
 	crdr_data->N = 1;
 	crdr_data->T = 1;
 	crdr_data->inv = 0;
+	baud_temp = (double)(crdr_data->D * crdr_data->fs / (double)crdr_data->F); 
 
 	for(i = 0 ; i < 4 ; i++)
 	{
@@ -1382,10 +1432,12 @@
 			crdr_data->D = 1;
 			crdr_data->T = 2; // will be set to T=1 in EnableSmartReader
 			crdr_data->fs = 6000000;
+			baud_temp = (double)(crdr_data->D * crdr_data->fs / (double)crdr_data->F);
 		}
 
 		smart_flush(reader);
-		EnableSmartReader(reader, crdr_data->fs / 10000, crdr_data->F, (unsigned char)crdr_data->D, crdr_data->N, crdr_data->T, crdr_data->inv, parity[i]);
+		crdr_data->parity = parity[i];
+		EnableSmartReader(reader, baud_temp, crdr_data->fs / 10000, crdr_data->F, (unsigned char)crdr_data->D, crdr_data->N, crdr_data->T, crdr_data->inv, parity[i]);
 
 		//Reset smartcard
 
@@ -1417,7 +1469,9 @@
 			rdr_debug_mask(reader, D_DEVICE, "SR: Inverse convention detected, setting smartreader inv to 1");
 
 			crdr_data->inv = 1;
-			EnableSmartReader(reader, crdr_data->fs / 10000, crdr_data->F, (unsigned char)crdr_data->D, crdr_data->N, crdr_data->T, crdr_data->inv, parity[i]);
+			smart_flush(reader);
+			crdr_data->parity = parity[i];
+			EnableSmartReader(reader, baud_temp, crdr_data->fs / 10000, crdr_data->F, (unsigned char)crdr_data->D, crdr_data->N, crdr_data->T, crdr_data->inv, parity[i]);
 		}
 		// parse atr
 		if(ATR_InitFromArray(atr, data, ret) != ERROR)
@@ -1457,8 +1511,8 @@
 static int32_t SR_GetStatus(struct s_reader *reader, int32_t *in)
 {
 	struct sr_data *crdr_data = reader->crdr_data; 
-	if (reader->smartdev_found >= 2 ) {
-//	rdr_log(reader, " de smart dev found = %u" , reader->smartdev_found); // needs to be removed after test
+	if (crdr_data->rdrtype == 2 || crdr_data->rdrtype == 3 || crdr_data->rdrtype == 4 || crdr_data->rdrtype == 5) {
+		if (crdr_data->rdrtype == 2 || crdr_data->rdrtype == 3 || crdr_data->rdrtype == 4 || crdr_data->rdrtype == 5) crdr_data->detectstart = 1;
     char usb_val[2];
     int32_t state2;
 
@@ -1466,28 +1520,30 @@
 	rdr_log(reader,"usb device unavailable");
 	return ERROR;
 	}
-	cs_writelock(&sr_lock);
+	rdr_debug_mask(reader, D_IFD, "THE DETECT START = %u card status is %u", crdr_data->detectstart, reader->card_status);
+	if (crdr_data->detectstart == 0) { *in = 1; return OK;} else
+	if (((crdr_data->detectstart == 1) && (reader->card_status != 1)) && ((crdr_data->detectstart == 1) && (reader->card_status != 0))) {
+	cs_writelock(&reader->sr_lock);
     if (libusb_control_transfer(crdr_data->usb_dev_handle, 
 								FTDI_DEVICE_IN_REQTYPE, 
 								SIO_POLL_MODEM_STATUS_REQUEST, 
-								0, crdr_data->index, 
+								2, crdr_data->index, 
 								(unsigned char *)usb_val, 
 								2, crdr_data->usb_read_timeout) != 1){
 	rdr_log(reader, "getting modem status failed ");
 	return ERROR;
 	}
-	cs_writeunlock(&sr_lock);
 	state2 = (usb_val[1] << 8) | (usb_val[0] & 0xFF);
-	rdr_debug_mask(reader, D_IFD, "the status of card in or out %u  (for v1 1152 is card out, for triple 1216 is card out or sometimes 192 is out for both)", state2); 
-
-    if ((state2 == 1216) || (state2 == 1152) || (state2 == 192)) {
+	cs_writeunlock(&reader->sr_lock);
+	rdr_debug_mask(reader, D_IFD, "the status of card in or out %u  ( 192 means card OUT)", state2);
+    if (state2 == 192) {
         *in = 0; //NOCARD reader will be set to off
 	}
     else {
         *in = 1; //Card is in Aktivation should be ok if card is activated
 	}
 	return OK;
-
+	} else {*in = 1;rdr_log(reader,"CARD STILL IN AKTIVATION PROCESS NO DETECTION"); return OK;}
 	} else {
 	int32_t state;
 
@@ -1503,9 +1559,8 @@
 	else
 		{ *in = 0; } //NOCARD
 
-//	return OK;
+	return OK;
 	}
- return OK;	
 }
 
 static int32_t SR_Receive(struct s_reader *reader, unsigned char *buffer, uint32_t size, uint32_t delay, uint32_t timeout)   // delay and timeout not used (yet)!
@@ -1515,7 +1570,7 @@
 	uint32_t  ret;
 
 	smart_fastpoll(reader, 1);
-	ret = smart_read(reader, buffer, size, 1);
+	ret = smart_read(reader, buffer, size, 2);
 	smart_fastpoll(reader, 0);
 	if(ret != size)
 		{ return ERROR; }
@@ -1540,17 +1595,26 @@
 	else if(reader->mhz >= 480)  { reader->mhz =  480; }
 	else if(reader->mhz >= 436)  { reader->mhz =  436; }
 	else if(reader->mhz >= 400)  { reader->mhz =  400; }
-	else if(reader->mhz >= 357)  { reader->mhz =  369; }
+	else if(reader->mhz >= 369)  { reader->mhz =  369; }
+	else if(reader->mhz == 368)  { reader->mhz =  369; }
 	else if(reader->mhz >= 343)  { reader->mhz =  343; }
 	else
 		{ reader->mhz =  320; }
-//	cs_writelock(&sr_lock);
-	smart_fastpoll(reader, 1);
-	rdr_log(reader," The EnableSmarReader is called out off Sr_writesettings");
-	EnableSmartReader(reader, reader->mhz, F, D, N, T, crdr_data->inv, crdr_data->parity);
-	smartreader_set_baudrate(reader, 3000000);
-	smart_fastpoll(reader, 0);
-//	cs_writeunlock(&sr_lock);
+	pthread_mutex_lock(&crdr_data->g_usb_mutex);
+	crdr_data->poll = 1;
+	pthread_cond_signal(&crdr_data->g_usb_cond);
+	pthread_mutex_unlock(&crdr_data->g_usb_mutex);
+	cs_writelock(&reader->sr_lock);
+	uint32_t baud_temp = (double)(D * (reader->mhz * 10000) / (double)F);
+	EnableSmartReader(reader, baud_temp, reader->mhz, F, D, N, T, crdr_data->inv, crdr_data->parity);
+	smartreader_set_baudrate(reader, baud_temp);
+	pthread_mutex_lock(&crdr_data->g_usb_mutex);
+	crdr_data->poll = 0;
+	pthread_cond_signal(&crdr_data->g_usb_cond);
+	pthread_mutex_unlock(&crdr_data->g_usb_mutex);
+	cs_sleepms(150);
+	cs_writeunlock(&reader->sr_lock);
+	rdr_log(reader,"de baudrate set = %u", baud_temp);
 
 	return OK;
 }
@@ -1578,7 +1642,7 @@
 	struct sr_data *crdr_data = reader->crdr_data;
 	if(!crdr_data) { return OK; }
 	rdr_debug_mask(reader, D_DEVICE, "SR: Closing smartreader");
-	cs_writelock(&sr_lock);
+	cs_writelock(&reader->sr_lock);
 	crdr_data->running = 0;
 	if(crdr_data->usb_dev_handle)
 	{
@@ -1588,14 +1652,14 @@
 		smart_fastpoll(reader, 0);
 		libusb_release_interface(crdr_data->usb_dev_handle, crdr_data->interface);
 #if defined(__linux__)
-		libusb_attach_kernel_driver(crdr_data->usb_dev_handle, crdr_data->interface);
+//		libusb_attach_kernel_driver(crdr_data->usb_dev_handle, crdr_data->interface); // attaching ftdio kernel driver may cause segfault on web if reader restart
 #endif
 		libusb_close(crdr_data->usb_dev_handle);
 		init_count--;
 		if(!init_count)
 			{ libusb_exit(NULL); }
 	}
-	cs_writeunlock(&sr_lock);
+	cs_writeunlock(&reader->sr_lock);
 	return OK;
 }
 
@@ -1632,7 +1696,7 @@
 	// A card with an active low reset is reset by maintaining RST in state L for at least 40 000 clock cycles
 	// so if we have a base freq of 3.5712MHz : 40000/3690000 = .0112007168458781 seconds, aka 11ms
 	// so if we have a base freq of 6.00MHz : 40000/6000000 = .0066666666666666 seconds, aka 6ms
-	cs_sleepms(20);
+	cs_sleepms(25);
 
 	//Set the DTR HIGH and RTS LOW
 	smartreader_setdtr_rts(reader, 1, 0);
@@ -1678,14 +1742,13 @@
 	return OK;
 }
 
-static pthread_mutex_t init_lock_mutex;
 
-static int32_t sr_init_locks(struct s_reader *UNUSED(reader))
+static int32_t sr_init_locks(struct s_reader *reader)
 {
 	// Prevent double initalization of sr_lock
-	if(pthread_mutex_trylock(&init_lock_mutex))
+	if(pthread_mutex_trylock(&reader->init_lock_mutex))
 	{
-		cs_lock_create(&sr_lock, 10, "sr_lock");
+		cs_lock_create(&reader->sr_lock, 0, "sr_lock");
 	}
 	return 0;
 }
Index: csctapi/icc_async.c
===================================================================
--- a/csctapi/icc_async.c	(revision 8984)
+++ b/csctapi/icc_async.c	(working copy)
@@ -30,6 +30,7 @@
 #include "protocol_t0.h"
 #include "io_serial.h"
 #include "ifd_phoenix.h"
+#include "../oscam-time.h"
 
 #define OK 0
 #define ERROR 1
@@ -304,20 +305,21 @@
 	return reader->crdr.do_reset(reader, atr, rdr_activate_card, rdr_get_cardsystem);
 }
 
+static uint32_t ICC_Async_GetClockRate_NewSmart(int32_t cardmhz)
+{
+ 	return (cardmhz * 10000L);
+}
 static uint32_t ICC_Async_GetClockRate(int32_t cardmhz)
 {
 	switch(cardmhz)
 	{
-	case 343:
-	case 347:
 	case 357:
 	case 358:
-	case 369:
 		return (372L * 9600L);
 	case 368:
 		return (384L * 9600L);
 	default:
-		return cardmhz * 10000L;
+		return (cardmhz * 10000L);
 	}
 }
 
@@ -593,6 +595,9 @@
 
 static uint32_t ETU_to_us(struct s_reader *reader, uint32_t ETU)
 {
+	if ((reader->typ == R_SMART) && (reader->smartdev_found >= 3))
+		return (uint32_t)((double) ETU * reader->worketu);  // in us
+	else 
 	return (uint32_t)((double) ETU * reader->worketu);  // in us
 }
 
@@ -658,15 +663,25 @@
 
 			if(reader->protocol_type != ATR_PROTOCOL_TYPE_T14)    //dont switch for T14
 			{
+				if ((reader->typ == R_SMART) && (reader->smartdev_found >= 3)){
+					uint32_t baud_temp = (double)D * ICC_Async_GetClockRate_NewSmart(reader->cardmhz) / (double)Fi; // just a test
+					rdr_log(reader, "Setting baudrate to %d bps new", baud_temp);
+					call(reader->crdr.set_baudrate(reader, baud_temp));
+					reader->current_baudrate = baud_temp;
+				} else {
 				uint32_t baud_temp = (double)D * ICC_Async_GetClockRate(reader->cardmhz) / (double)Fi;
 				rdr_log(reader, "Setting baudrate to %d bps", baud_temp);
 				call(reader->crdr.set_baudrate(reader, baud_temp));
 				reader->current_baudrate = baud_temp;
+				}				
 			}
 		}
 	}
-	if(reader->mhz > 2000 && reader->typ == R_INTERNAL) { F = reader->mhz / reader->divider; }  // for PLL based internal readers
+	if(reader->mhz > 2000 && reader->typ == R_INTERNAL) { F = reader->cardmhz; }  // for PLL based internal readers
 	else { F = reader->mhz; } // all other readers
+	if ((reader->typ == R_SMART) && (reader->smartdev_found >= 3))
+		reader->worketu = (double)((1 / (double)D) * ((double)Fi / (double)F * 100));  // expressed in us
+	else 
 	reader->worketu = (double)((1 / (double)D) * ((double)Fi / (double)F * 100));  // expressed in us
 	rdr_log(reader, "Calculated work ETU is %.2f us", reader->worketu);
 
@@ -832,7 +847,7 @@
 		if(reader->mhz > 2000)
 		{
 			rdr_log(reader, "PLL Reader: ATR Fsmax is %i MHz, clocking card to %.2f Mhz (nearest possible mhz specified reader->cardmhz)",
-					atr_fs_table[FI] / 1000000, (float) reader->mhz / reader->divider / 100);
+					atr_fs_table[FI] / 1000000, (float) reader->cardmhz / 100);
 		}
 		else
 		{
@@ -842,9 +857,9 @@
 	}
 	else
 	{
+		cs_sleepms(1000);
 		rdr_log(reader, "ATR Fsmax is %i MHz, clocking card to wanted user cardspeed of %.2f MHz (specified in reader->mhz)",
-				atr_fs_table[FI] / 1000000,
-				(float) reader->mhz / 100);
+				atr_fs_table[FI] / 1000000, (float) reader->mhz / 100);
 	}
 
 	//Communicate to T1 card IFSD -> we use same as IFSC
Index: oscam-config-reader.c
===================================================================
--- a/oscam-config-reader.c	(revision 8984)
+++ b/oscam-config-reader.c	(working copy)
@@ -324,6 +324,7 @@
 			{ "cccam",      R_CCCAM },
 			{ "cccam ext",  R_CCCAM },
 			{ "constcw",    R_CONSTCW },
+			{ "mcas",       R_MCAS },
 			{ "radegast",   R_RADEGAST },
 			{ "ghttp",      R_GHTTP },
 			{ "newcamd",    R_NEWCAMD },
Index: reader-nagra.c
===================================================================
--- a/reader-nagra.c	(revision 8984)
+++ b/reader-nagra.c	(working copy)
@@ -187,7 +187,7 @@
 static int32_t NegotiateSessionKey_Tiger(struct s_reader *reader)
 {
 	def_resp;
-	unsigned char vFixed[] = {0, 1, 2, 3, 0x11};
+	unsigned char exponent = 0x11;
 	unsigned char parte_fija[120];
 	unsigned char parte_variable[88];
 	unsigned char d1_rsa_modulo[88];
@@ -195,7 +195,7 @@
 	unsigned char sign1[8];
 	unsigned char sk[16];
 	unsigned char tmp[104];
-	unsigned char idea_sig[16];
+	unsigned char idea_key[16];
 	unsigned char rnd[88];
 	char tmp2[17];
 	struct nagra_data *csystem_data = reader->csystem_data;
@@ -215,7 +215,7 @@
 	BIGNUM *bnCT = BN_CTX_get(ctx);
 	BIGNUM *bnPT = BN_CTX_get(ctx);
 	BN_bin2bn(reader->rsa_mod, 120, bnN);
-	BN_bin2bn(vFixed + 4, 1, bnE);
+	BN_bin2bn(&exponent, 1, bnE);
 	BN_bin2bn(&cta_res[90], 120, bnCT);
 	BN_mod_exp(bnPT, bnCT, bnE, bnN, ctx);
 	memset(parte_fija, 0, 120);
@@ -226,8 +226,8 @@
 	rdr_debug_mask(reader, D_READER, "---------- SIG CHECK ---------------------");
 	memset(tmp, 0, 104);
 	memcpy(tmp + 4, parte_fija + 11, 100);
-	memset(idea_sig, 0x37, 16);
-	Signature(sign1, idea_sig, tmp, 104);
+	memset(idea_key, 0x37, 16);
+	Signature(sign1, idea_key, tmp, 104);
 	rdr_debug_mask(reader, D_READER, "sign1: %s", cs_hexdump(0, sign1, 8, tmp2, sizeof(tmp2)));
 	rdr_debug_mask(reader, D_READER, "sign2: %s", cs_hexdump(0, parte_fija + 111, 8, tmp2, sizeof(tmp2)));
 	if(!memcmp(parte_fija + 111, sign1, 8) == 0)
@@ -255,7 +255,7 @@
 	BIGNUM *bnCT1 = BN_CTX_get(ctx1);
 	BIGNUM *bnPT1 = BN_CTX_get(ctx1);
 	BN_bin2bn(d1_rsa_modulo, 88, bnN1);
-	BN_bin2bn(vFixed + 4, 1, bnE1);
+	BN_bin2bn(&exponent, 1, bnE1);
 	BN_bin2bn(cta_res + 2, 88, bnCT1);
 	BN_mod_exp(bnPT1, bnCT1, bnE1, bnN1, ctx1);
 	memset(parte_variable, 0, 88);
@@ -274,12 +274,13 @@
 	reader->prid[0][3] = parte_variable[74];
 	reader->caid = (SYSTEM_NAGRA | parte_variable[76]);
 	memcpy(sk, &parte_variable[79], 8);
-	memcpy(sk + 8, &parte_variable[79], 8);
+	memset(sk + 8, 0xBB, 8);
 	rdr_log_sensitive(reader, "type: NAGRA, caid: %04X, IRD ID: {%s}", reader->caid, cs_hexdump(1, reader->irdId, 4, tmp2, sizeof(tmp2)));
 	rdr_log(reader, "ProviderID: %s", cs_hexdump(1, reader->prid[0], 4, tmp2, sizeof(tmp2)));
 
-	memset(rnd, 0, 88);
-	memcpy(rnd, sk, 16);
+	memcpy(rnd, sk, 8);
+	memset(&rnd[8], 0xBB, 79);
+	rnd[87] = 0x6B;
 	ReverseMem(rnd, 88);
 
 
@@ -292,7 +293,7 @@
 	BIGNUM *bnCT3 = BN_CTX_get(ctx3);
 	BIGNUM *bnPT3 = BN_CTX_get(ctx3);
 	BN_bin2bn(d1_rsa_modulo, 88, bnN3);
-	BN_bin2bn(vFixed + 4, 1, bnE3);
+	BN_bin2bn(&exponent, 1, bnE3);
 	BN_bin2bn(rnd, 88, bnCT3);
 	BN_mod_exp(bnPT3, bnCT3, bnE3, bnN3, ctx3);
 	memset(d2_data, 0, 88);
Index: oscam-work.c
===================================================================
--- a/oscam-work.c	(revision 8984)
+++ b/oscam-work.c	(working copy)
@@ -256,7 +256,9 @@
 				}
 				break;
 			case ACTION_READER_RESET:
+#if WITH_CARDREADER == 1
 				cardreader_do_reset(reader);
+#endif
 				break;
 			case ACTION_READER_ECM_REQUEST:
 				reader_get_ecm(reader, data->ptr);
@@ -277,10 +279,14 @@
 				break;
 			case ACTION_READER_RESET_FAST:
 				reader->card_status = CARD_NEED_INIT;
+#if WITH_CARDREADER == 1
 				cardreader_do_reset(reader);
+#endif
 				break;
 			case ACTION_READER_CHECK_HEALTH:
+#if WITH_CARDREADER == 1
 				cardreader_do_checkhealth(reader);
+#endif
 				break;
 			case ACTION_READER_CAPMT_NOTIFY:
 				if(reader->ph.c_capmt) { reader->ph.c_capmt(cl, data->ptr); }
Index: oscam-client.c
===================================================================
--- a/oscam-client.c	(revision 8984)
+++ b/oscam-client.c	(working copy)
@@ -590,7 +590,9 @@
 
 		break;
 	case 'r':
+#if WITH_CARDREADER == 1
 		cardreader_checkhealth(cl, cl->reader);
+#endif
 		break;
 	case 'p':
 	{
@@ -674,8 +676,10 @@
 
 		if(rdr->ph.cleanup)
 			{ rdr->ph.cleanup(cl); }
+#if WITH_CARDREADER == 1
 		if(cl->typ == 'r')
 			{ cardreader_close(rdr); }
+#endif
 		if(cl->typ == 'p')
 			{ network_tcp_connection_close(rdr, "cleanup"); }
 		cl->reader = NULL;
Index: oscam-conf-mk.c
===================================================================
--- a/oscam-conf-mk.c	(revision 8984)
+++ b/oscam-conf-mk.c	(working copy)
@@ -824,7 +824,7 @@
 		{ return ""; }
 
 	int16_t i, tmp = 1, pos = 0, needed = 255, tagcnt;
-	char *tag[] = {"camd33", "camd35", "cs378x", "newcamd", "cccam", "gbox", "radegast", "dvbapi", "constcw", "serial"};
+	char *tag[] = {"camd33", "camd35", "cs378x", "newcamd", "cccam", "gbox", "radegast", "dvbapi", "constcw", "mcas", "serial"};
 	char *value, *dot = "";
 
 	if(!cs_malloc(&value, needed))
Index: config.sh
===================================================================
--- a/config.sh	(revision 8984)
+++ b/config.sh	(working copy)
@@ -1,7 +1,7 @@
 #!/bin/sh
 
 addons="WEBIF TOUCH HAVE_DVBAPI IRDETO_GUESSING CS_ANTICASC WITH_DEBUG MODULE_MONITOR WITH_SSL WITH_LB CS_CACHEEX CW_CYCLE_CHECK LCDSUPPORT LEDSUPPORT IPV6SUPPORT"
-protocols="MODULE_CAMD33 MODULE_CAMD35 MODULE_CAMD35_TCP MODULE_NEWCAMD MODULE_CCCAM MODULE_CCCSHARE MODULE_GBOX MODULE_RADEGAST MODULE_SERIAL MODULE_CONSTCW MODULE_PANDORA MODULE_GHTTP"
+protocols="MODULE_CAMD33 MODULE_CAMD35 MODULE_CAMD35_TCP MODULE_NEWCAMD MODULE_CCCAM MODULE_CCCSHARE MODULE_GBOX MODULE_RADEGAST MODULE_SERIAL MODULE_CONSTCW MODULE_MCAS MODULE_PANDORA MODULE_GHTTP"
 readers="READER_NAGRA READER_IRDETO READER_CONAX READER_CRYPTOWORKS READER_SECA READER_VIACCESS READER_VIDEOGUARD READER_DRE READER_TONGFANG READER_BULCRYPT READER_GRIFFIN READER_DGCRYPT"
 card_readers="CARDREADER_PHOENIX CARDREADER_INTERNAL CARDREADER_SC8IN1 CARDREADER_MP35 CARDREADER_SMARGO CARDREADER_DB2COM CARDREADER_STAPI CARDREADER_STINGER"
 
@@ -30,6 +30,7 @@
 CONFIG_MODULE_RADEGAST=y
 CONFIG_MODULE_SERIAL=y
 CONFIG_MODULE_CONSTCW=y
+CONFIG_MODULE_MCAS=n
 CONFIG_MODULE_PANDORA=y
 CONFIG_MODULE_GHTTP=y
 CONFIG_WITH_CARDREADER=y
@@ -442,6 +443,7 @@
 		MODULE_RADEGAST		"radegast"		$(check_test "MODULE_RADEGAST") \
 		MODULE_SERIAL		"Serial"		$(check_test "MODULE_SERIAL") \
 		MODULE_CONSTCW		"constant CW"	        $(check_test "MODULE_CONSTCW") \
+		MODULE_MCAS		"mcas"	        $(check_test "MODULE_MCAS") \
 		MODULE_PANDORA		"Pandora"		$(check_test "MODULE_PANDORA") \
 		MODULE_GHTTP		"Ghttp"			$(check_test "MODULE_GHTTP") \
 		2> ${tempfile}
Index: oscam.c
===================================================================
--- a/oscam.c	(revision 8984)
+++ b/oscam.c	(working copy)
@@ -345,6 +345,7 @@
 	write_conf(MODULE_RADEGAST, "radegast");
 	write_conf(MODULE_SERIAL, "serial");
 	write_conf(MODULE_CONSTCW, "constant CW");
+	write_conf(MODULE_MCAS, "mcas");
 
 	fprintf(fp, "\n");
 	write_conf(WITH_CARDREADER, "Reader support");
@@ -1177,6 +1178,9 @@
 #ifdef MODULE_CONSTCW
 		module_constcw,
 #endif
+#ifdef MODULE_MCAS
+		module_mcas,
+#endif
 #ifdef MODULE_RADEGAST
 		module_radegast,
 #endif
Index: cscrypt/i_cbc.c
===================================================================
--- a/cscrypt/i_cbc.c	(revision 8984)
+++ b/cscrypt/i_cbc.c	(working copy)
@@ -141,7 +141,7 @@
 	tin0 = tin1 = tout0 = tout1 = xor0 = xor1 = 0;
 	tin[0] = tin[1] = 0;
 }
-
+#ifndef MODULE_MCAS 
 void idea_encrypt(unsigned long *d, IDEA_KEY_SCHEDULE *key)
 {
 	register IDEA_INT *p;
@@ -176,3 +176,4 @@
 	d[0] = (t0 & 0xffff) | ((x1 & 0xffff) << 16);
 	d[1] = (x4 & 0xffff) | ((t1 & 0xffff) << 16);
 }
+#endif // #ifndef MODULE_MCAS 
Index: cscrypt/aes.c
===================================================================
--- a/cscrypt/aes.c	(revision 8984)
+++ b/cscrypt/aes.c	(working copy)
@@ -1,5 +1,5 @@
 #include "aes.h"
-
+#ifndef MODULE_MCAS 
 #ifndef WITH_LIBCRYPTO
 //FIXME Not checked on threadsafety yet; after checking please remove this line
 #include <assert.h>
@@ -1251,3 +1251,4 @@
 	PUTU32(out + 12, s3);
 }
 #endif
+#endif // #ifndef MODULE_MCAS 
Index: globals.h
===================================================================
--- a/globals.h	(revision 8984)
+++ b/globals.h	(working copy)
@@ -227,10 +227,10 @@
 #   define CS_TARGET "unknown"
 #endif
 #ifndef CS_CONFDIR
-#define CS_CONFDIR    "/usr/local/etc"
+#define CS_CONFDIR    "/mtd_rwcommon/oscam"
 #endif
 #ifndef CS_LOGFILE
-#define CS_LOGFILE    "/var/log/oscam.log"
+#define CS_LOGFILE    "/dtv/oscam.log"
 #endif
 #define CS_QLEN       128 // size of request queue
 #define CS_MAXCAIDTAB 32  // max. caid-defs/user
@@ -294,6 +294,7 @@
 #define R_CONSTCW   0x25  // Reader for Constant CW
 #define R_CSP       0x26  // Cache CSP
 #define R_GHTTP     0x27  // Reader ghttp
+#define R_MCAS      0x55  // mcas
 /////////////////// peer to peer proxy readers after R_CCCAM
 #define R_GBOX      0x30  // Reader cascading gbox
 #define R_CCCAM     0x35  // Reader cascading cccam
@@ -1316,8 +1317,13 @@
 	////variables from protocol_t1.h
 	uint16_t    ifsc;             // Information field size for the ICC
 	unsigned char ns;               // Send sequence number
-	int             smartdev_found;
+	int16_t             smartdev_found;
+	int16_t				smart_type;
+#ifdef CARDREADER_SMART
+	CS_MUTEX_LOCK 	sr_lock;						// moved from ifd_smartreader.c 
+	pthread_mutex_t init_lock_mutex;				// moved from ifd_smartreader.c 
 #endif
+#endif
 	unsigned char   rom[15];
 	unsigned char   irdId[4];
 #ifdef WITH_LB
Index: oscam-emm.c
===================================================================
--- a/oscam-emm.c	(revision 8984)
+++ b/oscam-emm.c	(working copy)
@@ -561,7 +561,9 @@
 		else
 		{
 			rdr_debug_mask(reader, D_READER, "local emm reader");
+#if WITH_CARDREADER == 1
 			rc = cardreader_do_emm(reader, ep);
+#endif
 		}
 		if(!ecs)
 			{ i = reader_store_emm(ep->type, md5tmp); }
@@ -631,7 +633,10 @@
 	reader->s_nano = reader->b_nano = 0;
 	reader->saveemm = 0;
 
-	int32_t rc = cardreader_do_emm(reader, eptmp);
+    int32_t rc = 0;
+#if WITH_CARDREADER == 1
+	rc = cardreader_do_emm(reader, eptmp);
+#endif
 	if(rc == OK)
 		{ rdr_log(reader, "EMM from file %s was successful written.", token); }
 	else
Index: Distribution/doc/txt/oscam.server.txt
===================================================================
--- a/Distribution/doc/txt/oscam.server.txt	(revision 8984)
+++ b/Distribution/doc/txt/oscam.server.txt	(working copy)
@@ -98,10 +98,25 @@
 	  set standard SC frequency in units of 10 kHz, for Irdeto SC set to 600, for auto clock speed in Dreambox mode  set  to
 	  -1, refer to OVERCLOCKING, default:357
 
-       mhz = frequency
-	  set reader frequency in units of 10 kHz, if mhz > cardmhz you are in overclocking mode, for cardmhz swiching to MIPSel
-	  Dreambox mode set to 2700, for cardmhz swiching to PPC Dreambox mode set to 3150, for  cardmhz  swiching  to	Dreambox
-	  DM7025 mode set to 8300, refer to OVERCLOCKING, default:357
+       mhz = frequency *** EXTERNAL READERS ***
+	  set reader frequency in units of 10 kHz, if mhz > cardmhz you are in overclocking mode
+	  default:357
+	  
+	   mhz = frequency *** INTERNAL READERS ***
+	  set reader frequency in units of 10 kHz. If you use mhz >2000 oscam will switch to PLL clocking.
+	  Internal readers of boxes from Dream Multimedia GmbH can be clocked more precise with it.
+	  The used mhz should reflect the highest frequency of the PLL crystal in the internal cardreader.
+	  Oscam will calculate the best PLL divider that comes nearest to the wanted user card speed specified in cardmhz. 
+	  For models with PPC cpu use mhz = 3150, for models with MIPS cpu use mhz = 2700. Exception is the DM7025, you should use mhz = 8300
+	  E.G. You have a dream 800 HD PVR, thats a mips so you should set mhz to 2700. We got a nagra card that should run on 5 Mhz.
+	  If you want to clock the card ok just use mhz = 2700 and cardmhz = 500. If you want to overclock it use mhz = 2700 and cardmhz = 900
+	  Now your card will start to run 9 Mhz. Better monitor it! An overclocked card could run hot or crash suddenly.
+	  
+	  Keep in mind that most internal readers of non-dreamboxes clock the cards automatically and completely ignore any user clockspeed setting.
+	  But you should set mhz and cardmhz anyway, as its still used to calculate the correct timings in oscam. If you set mhz / cardmhz correct the timings
+	  will better match with the actual (automaticaly) clockspeed of the internal card reader. As for a result slighly better ecm responses or more stable
+	  functioning. Dont expect magic here, only overclocking the cardspeed can reduce the ecm response time. Bad timings can only delay it or make the card
+	  responses instable!
 
        deprecated = 0|1
 	  First  the  SC  will	be  initialized in normal mode. If it fails, the SC will be automatically reverted to deprecated
@@ -455,18 +470,9 @@
 	  1 = use SSL for ghttp protocol, default:0
 
 OVERCLOCKING
-         Dreambox and other internal readers
 
-	  For Dreambox and other internal readers the highest possible clockrate will be auto detected. The mhz  parameter  lets
-	  you  override  the  values chosen by OSCam, if it differs from 357 and 358, but usually you will not set any value for
-	  mhz.
 
-	  For certain Dreamboxes (especially PPC clones) the default mhz parameter leads to slow ECM times  and/or  "not  found"
-	  ECMs. By setting mhz to values like 200, 300, 400, ... 1600 you can find a value that works for your receiver and your
-	  card. The higher the mhz value, the slower the ECM time (strange enough).
 
-	  If you choose the value too low, your card is not recognized (no ATR or "card not supported"). If you choose the value
-	  too high, you get slow ECM times. Our experience is that either no mhz line, or a line mhz = 1000 works best.
 
          Phoenix / Smartmouse reader
 
